<template>
  <div
    ref="dropdown"
    v-click-outside:[isActiveClickOutside]="closeHandler.bind(this, { focusToggle: false })"
    class="ui-dropdown"
    :class="{ 'is-active': isOpen }"
    @keydown="dropdownKeydownHandler"
  >
    <!-- @slot Use this slot to place toggle template. -->
    <slot
      name="toggle"
      v-bind="{
        toggleHandler,
        openHandler,
        closeHandler,
        isOpen,
        text,
        buttonAttrs,
        buttonToggleAttrs,
      }"
    >
      <UiButton
        v-bind="buttonAttrs || buttonToggleAttrs"
        ref="toggle"
        class="ui-dropdown__toggle"
        :aria-expanded="`${isOpen}`"
        @click="toggleHandler"
      >
        {{ text }}
      </UiButton>
    </slot>
    <!-- @slot Use this slot to replace popover template. -->
    <slot
      name="popover"
      v-bind="{
        closeHandler,
        isOpen,
        popoverAttrs
      }"
    >
      <UiPopover
        v-if="isOpen"
        v-bind="popoverAttrs"
        class="ui-dropdown__popover"
        @close="closeHandler"
      >
        <!-- @slot Use this slot to replace content template. -->
        <slot
          name="content"
          v-bind="{
            closeHandler,
            isOpen
          }"
        >
          <div
            role="radiogroup"
            class="ui-dropdown__items"
          >
            <!-- @slot Use this slot to place dropdown content inside dropdown. -->
            <slot
              v-bind="{
                closeHandler,
                isOpen
              }"
            >
              <template
                v-for="(item, key) in itemsToRender"
                :key="key"
              >
                <UiDropdownItem
                  v-bind="dropdownItemAttrs(item)"
                >
                  <!-- @slot Use this slot to replace dropdown item content. -->
                  <slot
                    :name="item.name"
                    v-bind="{ item }"
                  >
                    {{ item.text }}
                  </slot>
                </UiDropdownItem>
              </template>
            </slot>
          </div>
        </slot>
      </UiPopover>
    </slot>
  </div>
</template>

<script setup lang="ts">
import { uid } from 'uid/single';
import {
  ref,
  computed,
  provide,
  nextTick,
  useAttrs,
} from 'vue';
import type {
  PropType,
  VNode,
} from 'vue';
import useDropdownItems from './useDropdownItems';
import { clickOutside as vClickOutside } from '../../../utilities/directives';
import { focusElement } from '../../../utilities/helpers/index';
import UiDropdownItem from './_internal/UiDropdownItem.vue';
import UiButton from '../../atoms/UiButton/UiButton.vue';
import UiPopover from '../UiPopover/UiPopover.vue';
import type { PropsAttrs } from '../../../types/attrs';

export type DropdownValue = string | Record<string, unknown>
export interface DropdownItemAsObj {
  text?: string;
  name?: string;
  value: DropdownValue;
  [key: string]: DropdownValue | undefined;
}
export type DropdownItem = string | DropdownItemAsObj;
export type ButtonEl = InstanceType<typeof UiButton>;
export interface openOptions {
  focus?: boolean
}
export interface closeOptions {
  focusToggle?: boolean
}
const props = defineProps({
  /**
   * Use this props to set text on toggle button.
   */
  text: {
    type: String,
    default: '',
  },
  /**
   * Use this props to set dropdown name.
   * Default value is generated by uid i.e. `dropdown-<uid>`.
   */
  name: {
    type: String,
    default: '',
  },
  /**
   * Use this props or v-model to set value.
   */
  modelValue: {
    type: [
      String,
      Object,
    ] as PropType<DropdownValue>,
    default: '',
  },
  /**
   * Use this props to allow clicking outside to close dropdown.
   */
  closeOnClickOutside: {
    type: Boolean,
    default: true,
  },
  /**
   * Use this props to set toggle DOM element to back to it after close popover.
   */
  toggleElement: {
    type: Object as PropType<null | HTMLElement>,
    default: undefined,
  },
  /**
   * Use this props to allow using key navigation.
   */
  enableKeyboardNavigation: {
    type: Boolean,
    default: true,
  },
  /**
   * Use this props to pass list of dropdown items.
   */
  items: {
    type: Array as PropType<DropdownItem[]>,
    default: () => [],
  },
  /**
   *  Use this props to pass attrs to toggle UiButton.
   */
  buttonToggleAttrs: {
    type: Object as PropsAttrs,
    default: () => ({}),
  },
  /**
   *  Use this props to pass attrs to UiPopover.
   */
  popoverAttrs: {
    type: Object as PropsAttrs,
    default: () => ({}),
  },
});
const emit = defineEmits<{(e: 'update:modelValue', value: DropdownValue): void;
  (e: 'open'): void;
  (e: 'close'): void;
}>();
const toggle = ref<ButtonEl|null>(null);
const dropdown = ref<null | HTMLDivElement>(null);
const isOpen = ref(false);
const dropdownToggle = computed<VNode | ButtonEl>(
  () => props.toggleElement || toggle.value?.$el,
);
const {
  dropdownItems,
  activeDropdownItemIndex,
  firstDropdownItem,
  lastDropdownItem,
  nextDropdownItem,
  prevDropdownItem,
  selectedDropdownItem,
} = useDropdownItems(dropdown);
function disableArrows(event: KeyboardEvent): void {
  if ([
    'ArrowUp',
    'ArrowDown',
  ].indexOf(event.code) > -1) {
    event.preventDefault();
  }
}
async function openHandler({ focus = false }: openOptions = {}): Promise<void> {
  isOpen.value = true;
  emit('open');
  window.addEventListener('keydown', disableArrows, false);

  await nextTick();

  if (focus) {
    if (selectedDropdownItem.value) focusElement(selectedDropdownItem.value);
    else if (nextDropdownItem.value) focusElement(nextDropdownItem.value);
  }
}

function closeHandler({ focusToggle }: closeOptions = { focusToggle: true }): void {
  if (dropdownToggle.value && focusToggle) {
    ((dropdownToggle.value as ButtonEl).$el || dropdownToggle.value).focus();
  }
  isOpen.value = false;
  emit('close');
  window.removeEventListener('keydown', disableArrows, false);
}

async function toggleHandler(): Promise<void> {
  if (isOpen.value) {
    closeHandler();
  } else {
    await openHandler({ focus: true });
  }
}
const isActiveClickOutside = computed(() => (props.closeOnClickOutside && isOpen.value));
const dropdownName = computed(() => (
  props.name || `dropdown-${uid()}`
));
provide('name', dropdownName);
const modelValue = computed(() => props.modelValue);
provide('modelValue', modelValue);
function changeHandler(value: DropdownValue): void {
  emit('update:modelValue', value);
  closeHandler();
}
provide('changeHandler', changeHandler);
async function dropdownKeydownHandler({ key }: { key: string }): Promise<void> {
  if (!props.enableKeyboardNavigation) return;

  switch (key) {
    case 'Tab':
    case 'Escape':
      closeHandler();
      break;
    case 'ArrowDown':
      if (!isOpen.value) {
        await openHandler({ focus: true });
      } else {
        focusElement(nextDropdownItem.value);
      }
      break;
    case 'ArrowUp':
      focusElement(prevDropdownItem.value);
      break;
    case 'Home':
    case 'PageUp':
      focusElement(firstDropdownItem.value);
      break;
    case 'End':
    case 'PageDown':
      focusElement(lastDropdownItem.value);
      break;
    default: break;
  }
}
// todo: why this component handle searchQuery and searchDebounce?
const searchQuery = ref('');
const searchDebounce = ref<ReturnType<typeof setTimeout> | null>(null);
function handleInputQuery({ key }: { key: string }): void {
  searchQuery.value += key.toLowerCase();
  const match: number = dropdownItems.value.findIndex(
    (item: HTMLElement) => item.innerText.toLowerCase().startsWith(searchQuery.value),
  );
  if (match !== -1 && match !== activeDropdownItemIndex.value) focusElement(dropdownItems.value[match]);
}
async function dropdownItemKeydownHandler(event: KeyboardEvent): Promise<void> {
  const { key } = event;
  if (searchDebounce.value) clearTimeout(searchDebounce.value);

  if (key.length === 1) {
    handleInputQuery(event);
    searchDebounce.value = setTimeout(() => { searchQuery.value = ''; }, 500);
  }
}
provide('dropdownItemKeydownHandler', dropdownItemKeydownHandler);

defineExpose({
  isOpen,
  closeHandler,
});

const itemsToRender = computed(() => (props.items.map((item, key) => {
  if (typeof item === 'string' || typeof item === 'number') {
    return {
      name: `dropdown-item-${key}`,
      text: item,
      value: item,
    };
  }
  return {
    ...item,
    name: item.name || `dropdown-item-${key}`,
    value: item.value || JSON.parse(JSON.stringify(item)),
  };
})));

// TODO: remove in 0.6.0 / BEGIN
const attrs = useAttrs();
const buttonAttrs = computed(() => attrs.buttonAttrs || attrs['button-attrs']);
if (buttonAttrs.value) {
  if (process.env.NODE_ENV === 'development') {
    console.warn('[@infermedica/component-library warn][UiDropdown]: The `buttonAttrs` props will be removed in 0.6.0. Please use `buttonToggleAttrs` props instead.');
  }
}
// END
const dropdownItemAttrs = (item: DropdownItemAsObj) => {
  const {
    name, text, ...rest
  } = item;
  return rest;
};
</script>

<style lang="scss">
@use "../../../styles/functions";
@use "../../../styles/mixins";

.ui-dropdown {
  $element: dropdown;

  position: relative;
  display: inline-flex;

  &__popover {
    --popover-content-padding-logical: #{functions.var($element + "-popover", padding-logical, var(--space-8))};

    @include mixins.use-logical($element + "-popover", margin, var(--space-8) 0 0);
    @include mixins.use-logical($element + "-popover", inset, 100% auto auto 0);

    position: absolute;
    width: functions.var($element + "-popover", width, 100%);
    max-width: functions.var($element + "-popover", max-width, 15rem);
    min-height: functions.var($element + "-popover", min-height, 0);
  }

  &__items {
    display: flex;
    flex: 1;
    flex-direction: column;
  }

  &--compact {
    --dropdown-item-padding: var(--space-4) var(--space-8);
  }
}
</style>

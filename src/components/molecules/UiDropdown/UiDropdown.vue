<template>
  <div
    ref="dropdown"
    v-click-outside:[isActiveClickOutside]="closeHandler.bind(this, { focusToggle: false })"
    class="ui-dropdown"
    :class="{'is-active': isOpen}"
    @keydown="dropdownKeydownHandler"
  >
    <!-- @slot Use this slot to place toggle template. -->
    <slot
      name="toggle"
      v-bind="{toggleHandler, openHandler, closeHandler, isOpen, text, attrs: buttonAttrs}"
    >
      <UiButton
        v-bind="buttonAttrs"
        ref="toggle"
        class="ui-dropdown__toggle"
        :aria-expanded="`${isOpen}`"
        @click="toggleHandler"
      >
        {{ text }}
      </UiButton>
    </slot>
    <!-- @slot Use this slot to replace popover template. -->
    <slot
      name="popover"
      v-bind="{closeHandler, isOpen, attrs: popoverAttrs}"
    >
      <UiPopover
        v-if="isOpen"
        v-bind="popoverAttrs"
        class="ui-dropdown__popover"
        @close="closeHandler"
      >
        <!-- @slot Use this slot to replace content template. -->
        <slot
          name="content"
          v-bind="{closeHandler, isOpen}"
        >
          <div role="radiogroup">
            <!-- @slot Use this slot to place dropdown content inside dropdown. -->
            <slot v-bind="{closeHandler, isOpen}">
              <template
                v-for="(item, key) in itemsToRender"
                :key="key"
              >
                <UiDropdownItem :value="item.value">
                  <!-- @slot Use this slot to replace dropdown item content. -->
                  <slot
                    :name="item.name"
                    v-bind="{item}"
                  >
                    {{ item.text }}
                  </slot>
                </UiDropdownItem>
              </template>
            </slot>
          </div>
        </slot>
      </UiPopover>
    </slot>
  </div>
</template>

<script setup>
import { uid } from 'uid/single';
import {
  ref, computed, provide, nextTick,
} from 'vue';
import useDropdownItems from './useDropdownItems';
import { clickOutside as vClickOutside } from '../../../utilities/directives';
import UiDropdownItem from './_internal/UiDropdownItem.vue';
import UiButton from '../../atoms/UiButton/UiButton.vue';
import UiPopover from '../UiPopover/UiPopover.vue';

const props = defineProps({
  /**
   * Use this props to set text on toggle button.
   */
  text: {
    type: String,
    default: '',
  },
  /**
   * Use this props to set dropdown name.
   * Default value is generated by uid i.e. `dropdown-<uid>`.
   */
  name: {
    type: String,
    default: '',
  },
  /**
   * Use this props or v-model to set value.
   */
  modelValue: {
    type: [String, Object],
    default: '',
  },
  /**
   * Use this props to allow clicking outside to close dropdown.
   */
  closeOnClickOutside: {
    type: Boolean,
    default: true,
  },
  /**
     * Use this props to set toggle DOM element to back to it after close popover.
     */
  toggleElement: {
    type: Object,
    default: undefined,
  },
  /**
   * Use this props to allow using key navigation.
   */
  enableKeyboardNavigation: {
    type: Boolean,
    default: true,
  },
  /**
   *  Use this props to pass attrs to UiButton.
   */
  buttonAttrs: {
    type: Object,
    default: () => ({}),
  },
  /**
   *  Use this props to pass attrs to UiPopover.
   */
  popoverAttrs: {
    type: Object,
    default: () => ({}),
  },
  /**
   * Use this props to pass list of dropdown items.
   */
  items: {
    type: Array,
    default: () => [],
  },
});
const emit = defineEmits(['update:modelValue', 'open', 'close']);
const toggle = ref(null);
const dropdown = ref(null);
const isOpen = ref(false);
const dropdownToggle = computed(() => (props.toggleElement || toggle.value?.$el));
const {
  dropdownItems,
  activeDropdownItemIndex,
  firstDropdownItem,
  lastDropdownItem,
  nextDropdownItem,
  prevDropdownItem,
  selectedDropdownItem,
} = useDropdownItems(dropdown);
async function openHandler({ focus = false } = {}) {
  isOpen.value = true;
  emit('open');

  await nextTick();

  if (focus) {
    if (selectedDropdownItem.value) selectedDropdownItem.value.focus();
    else if (nextDropdownItem.value) nextDropdownItem.value.focus();
  }
}

function closeHandler({ focusToggle } = { focusToggle: true }) {
  if (dropdownToggle.value && focusToggle) {
    (dropdownToggle.value?.$el || dropdownToggle.value).focus();
  }
  isOpen.value = false;
  emit('close');
}

async function toggleHandler() {
  if (isOpen.value) {
    closeHandler();
  } else {
    await openHandler({ focus: true });
  }
}
const isActiveClickOutside = computed(() => (props.closeOnClickOutside && isOpen.value));
const dropdownName = computed(() => (
  props.name || `dropdown-${uid()}`
));
provide('name', dropdownName);
const modelValue = computed(() => (props.modelValue));
provide('modelValue', modelValue);
function changeHandler(value) {
  emit('update:modelValue', value);
  closeHandler();
}
provide('changeHandler', changeHandler);
const dropdownKeydownHandler = async ({ key }) => {
  if (!props.enableKeyboardNavigation) return;

  switch (key) {
    case 'Tab':
    case 'Escape':
      closeHandler();
      break;
    case 'ArrowDown':
      if (!isOpen.value) {
        await openHandler({ focus: true });
      } else {
        nextDropdownItem.value.focus();
      }
      break;
    case 'ArrowUp':
      prevDropdownItem.value.focus();
      break;
    case 'Home':
    case 'PageUp':
      firstDropdownItem.value.focus();
      break;
    case 'End':
    case 'PageDown':
      lastDropdownItem.value.focus();
      break;
    default: break;
  }
};
const searchQuery = ref('');
const searchDebounce = ref(null);
const handleInputQuery = ({ key }) => {
  searchQuery.value += key.toLowerCase();
  const match = dropdownItems.value.findIndex(
    (item) => item.innerText.toLowerCase().startsWith(searchQuery.value),
  );

  if (match !== -1 && match !== activeDropdownItemIndex.value) dropdownItems.value[match].focus();
};
const dropdownItemKeydownHandler = async (event) => {
  const { key } = event;
  if (searchDebounce.value) clearTimeout(searchDebounce.value);

  if (key.length === 1) {
    handleInputQuery(event);
    searchDebounce.value = setTimeout(() => { searchQuery.value = ''; }, 500);
  }
};
provide('dropdownItemKeydownHandler', dropdownItemKeydownHandler);

defineExpose({ isOpen, closeHandler });

const itemsToRender = computed(() => (props.items.map((item, key) => {
  if (typeof item === 'string') {
    return {
      name: `dropdown-item-${key}`,
      text: item,
      value: item,
    };
  }
  return {
    name: item.name || `dropdown-item-${key}`,
    ...item,
    value: item.value || item,
  };
})));
</script>

<style lang="scss">
.ui-dropdown {
  position: relative;
  display: inline-block;

  &__toggle {
    width: var(--dropdown-toggle-width, 100%);
  }

  &__popover {
    position: absolute;
    top: var(--dropdown-popover-top, 100%);
    left: var(--dropdown-popover-left, unset);
    width: var(--dropdown-popover-width, 100%);
    max-width: var(--dropdown-popover-max-width, unset);
    min-height: var(--dropdown-popover-min-height, 0);
    transform: var(--dropdown-popover-transform, translateY(var(--space-8)));
  }

  &--compact {
    --dropdown-item-button-padding: var(--space-4) var(--space-8);
  }
}
</style>

<template>
  <div
    ref="dropdown"
    v-click-outside="clickOutsideValue"
    class="ui-dropdown"
    :class="{ 'is-active': isOpen }"
    @keydown="dropdownKeydownHandler"
  >
    <!-- @slot Use this slot to place toggle template. -->
    <slot
      name="toggle"
      v-bind="{
        toggleHandler,
        openHandler,
        closeHandler,
        isOpen,
        text,
        buttonToggleAttrs,
      }"
    >
      <UiButton
        v-bind="buttonToggleAttrs"
        ref="toggle"
        class="ui-dropdown__toggle"
        :aria-expanded="`${isOpen}`"
        @click="toggleHandler"
      >
        {{ text }}
      </UiButton>
    </slot>
    <!-- @slot Use this slot to replace popover template. -->
    <slot
      name="popover"
      v-bind="{
        closeHandler,
        isOpen,
        popoverAttrs,
      }"
    >
      <UiPopover
        v-if="isOpen"
        v-bind="popoverAttrs"
        class="ui-dropdown__popover"
        @close="closeHandler"
      >
        <!-- @slot Use this slot to replace content template. -->
        <slot
          name="content"
          v-bind="{
            closeHandler,
            isOpen,
          }"
        >
          <div
            role="radiogroup"
            class="ui-dropdown__items"
          >
            <!-- @slot Use this slot to place dropdown content inside dropdown. -->
            <slot
              v-bind="{
                closeHandler,
                isOpen,
              }"
            >
              <template
                v-for="(item, key) in itemsToRender"
                :key="key"
              >
                <UiDropdownItem
                  v-bind="dropdownItemAttrs(item)"
                >
                  <!-- @slot Use this slot to replace dropdown item content. -->
                  <slot
                    :name="item.name"
                    v-bind="{ item }"
                  >
                    {{ item.text }}
                  </slot>
                </UiDropdownItem>
              </template>
            </slot>
          </div>
        </slot>
      </UiPopover>
    </slot>
  </div>
</template>

<script setup lang="ts">
import { uid } from 'uid/single';
import {
  ref,
  computed,
  provide,
  nextTick,
  type ComputedRef,
  type ComponentPublicInstance,
} from 'vue';
import useDropdownItems from './useDropdownItems';
import {
  clickOutside as vClickOutside,
  type VClickOutsideValue,
} from '../../../utilities/directives';
import { focusElement } from '../../../utilities/helpers';
import UiDropdownItem from './_internal/UiDropdownItem.vue';
import type { DropdownItemAttrsProps } from './_internal/UiDropdownItem.vue';
import UiButton from '../../atoms/UiButton/UiButton.vue';
import type { ButtonAttrsProps } from '../../atoms/UiButton/UiButton.vue';
import UiPopover from '../UiPopover/UiPopover.vue';
import type { PopoverAttrsProps } from '../UiPopover/UiPopover.vue';
import type { DefineAttrsProps } from '../../../types';

export type ButtonInstance = InstanceType<typeof UiButton>;
export interface DropdownItemComplex extends DropdownItemAttrsProps {
    text?: string;
    name?: string;
}
export type DropdownItem = string | DropdownItemComplex;
export interface DropdownHandlersOptions {
    focus?: boolean;
    focusToggle?: boolean;
}
export type DropdownModelValue = string | Record<string, unknown>;
export type DropdownItemKeydownHandler = ({ key }: KeyboardEvent) => void;
export type DropdownChangeHandler = (value: DropdownModelValue) => void;
export interface DropdownProps {
  /**
   * Use this props to set text on toggle button.
   */
  text?: string;
  /**
   * Use this props to set dropdown name.
   * Default value is generated by uid i.e. `dropdown-<uid>`.
   */
  name?: string;
  /**
   * Use this props or v-model to set value.
   */
  modelValue?: DropdownModelValue;
  /**
   * Use this props to allow clicking outside to close dropdown.
   */
  closeOnClickOutside?: boolean;
  /**
   * Use this props to set toggle DOM element to back to it after close popover.
   */
  toggleElement?: ComponentPublicInstance | HTMLElement | null;
  /**
   * Use this props to allow using key navigation.
   */
  enableKeyboardNavigation?: boolean;
  /**
   * Use this props to pass list of dropdown items.
   */
  items?: DropdownItem[];
  /**
   *  Use this props to pass attrs to toggle UiButton.
   */
  buttonToggleAttrs?: ButtonAttrsProps;
  /**
   *  Use this props to pass attrs to UiPopover.
   */
  popoverAttrs?: PopoverAttrsProps;
}
export type DropdownAttrsProps = DefineAttrsProps<DropdownProps>
export interface DropdownEmits {
  (e: 'update:modelValue', value: DropdownModelValue): void;
  (e: 'open'): void;
  (e: 'close'): void;
}

const props = withDefaults(defineProps<DropdownProps>(), {
  text: '',
  name: '',
  modelValue: '',
  closeOnClickOutside: true,
  toggleElement: undefined,
  enableKeyboardNavigation: true,
  items: () => ([]),
  buttonToggleAttrs: () => ({}),
  popoverAttrs: () => ({}),
});
const emit = defineEmits<DropdownEmits>();
const toggle = ref<ButtonInstance | null>(null);
const dropdown = ref<HTMLElement | null>(null);
const isOpen = ref(false);
const dropdownToggle = computed<HTMLElement>(
  () => {
    if (!props.toggleElement) {
      return toggle.value?.$el;
    }
    return '$el' in props.toggleElement
      ? props.toggleElement.$el
      : props.toggleElement;
  },
);
const {
  dropdownItems,
  activeDropdownItemIndex,
  firstDropdownItem,
  lastDropdownItem,
  nextDropdownItem,
  prevDropdownItem,
  selectedDropdownItem,
} = useDropdownItems(dropdown);
const disableArrows = (event: KeyboardEvent) => {
  if ([
    'ArrowUp',
    'ArrowDown',
  ].indexOf(event.code) > -1) {
    event.preventDefault();
  }
};
const openHandler = async ({ focus = false }: DropdownHandlersOptions = {}) => {
  isOpen.value = true;
  emit('open');
  window.addEventListener('keydown', disableArrows, false);

  await nextTick();

  if (focus) {
    if (selectedDropdownItem.value) focusElement(selectedDropdownItem.value);
    else if (nextDropdownItem.value) focusElement(nextDropdownItem.value);
  }
};
const closeHandler = ({ focusToggle }: DropdownHandlersOptions = { focusToggle: true }) => {
  if (dropdownToggle.value && focusToggle) {
    dropdownToggle.value.focus();
  }
  isOpen.value = false;
  emit('close');
  window.removeEventListener('keydown', disableArrows, false);
};
const toggleHandler = async () => {
  if (isOpen.value) {
    closeHandler();
  } else {
    await openHandler({ focus: true });
  }
};
const clickOutsideValue = computed<VClickOutsideValue>(() => ({
  isActive: props.closeOnClickOutside && isOpen.value,
  handler: () => closeHandler({ focusToggle: false }),
}));
const dropdownName = computed(() => (
  props.name || `dropdown-${uid()}`
));
provide<ComputedRef<string>>('name', dropdownName);
const modelValue = computed(() => props.modelValue);
provide<ComputedRef<DropdownProps['modelValue']>>('modelValue', modelValue);
const changeHandler: DropdownChangeHandler = (value) => {
  emit('update:modelValue', value);
  closeHandler();
};
provide<DropdownChangeHandler>('changeHandler', changeHandler);
const dropdownKeydownHandler = async ({ key }: KeyboardEvent) => {
  if (!props.enableKeyboardNavigation) return;

  switch (key) {
    case 'Tab':
    case 'Escape':
      closeHandler();
      break;
    case 'ArrowDown':
      if (!isOpen.value) {
        await openHandler({ focus: true });
      } else if (nextDropdownItem.value) {
        focusElement(nextDropdownItem.value);
      }
      break;
    case 'ArrowUp':
      if (prevDropdownItem.value) {
        focusElement(prevDropdownItem.value);
      }
      break;
    case 'Home':
    case 'PageUp':
      if (firstDropdownItem.value) {
        focusElement(firstDropdownItem.value);
      }
      break;
    case 'End':
    case 'PageDown':
      if (lastDropdownItem.value) {
        focusElement(lastDropdownItem.value);
      }
      break;
    default: break;
  }
};
// todo: why this component handle searchQuery and searchDebounce?
const searchQuery = ref('');
const searchDebounce = ref<ReturnType<typeof setTimeout> | null>(null);
const handleInputQuery = (key: KeyboardEvent['key']) => {
  searchQuery.value += key.toLowerCase();
  const match: number = dropdownItems.value.findIndex(
    (item: HTMLElement) => item.innerText.toLowerCase().startsWith(searchQuery.value),
  );
  if (match !== -1 && match !== activeDropdownItemIndex.value) focusElement(dropdownItems.value[match]);
};
const dropdownItemKeydownHandler: DropdownItemKeydownHandler = ({ key }) => {
  if (searchDebounce.value) clearTimeout(searchDebounce.value);
  if (key.length === 1) {
    handleInputQuery(key);
    searchDebounce.value = setTimeout(() => { searchQuery.value = ''; }, 500);
  }
};
provide<DropdownItemKeydownHandler>('dropdownItemKeydownHandler', dropdownItemKeydownHandler);
defineExpose({
  isOpen,
  closeHandler,
});
const itemsToRender = computed<DropdownItemComplex[]>(() => (props.items.map((item, key) => {
  if (typeof item === 'string') {
    return {
      name: `dropdown-item-${key}`,
      text: item,
      value: item,
    };
  }
  return {
    ...item,
    name: item.name || `dropdown-item-${key}`,
    value: item.value || JSON.parse(JSON.stringify(item)),
  };
})));
const dropdownItemAttrs = ({
  name, text, ...itemAttrs
}: DropdownItemComplex) => itemAttrs;
</script>

<style lang="scss">
@use "../../../styles/functions";
@use "../../../styles/mixins";

.ui-dropdown {
  $element: dropdown;

  position: relative;
  display: inline-flex;

  &__popover {
    @include mixins.override-logical(popover-content, $element + "-popover", padding, var(--space-8));
    @include mixins.use-logical($element + "-popover", margin, var(--space-8) 0 0);
    @include mixins.use-logical($element + "-popover", inset, 100% auto auto 0);

    position: absolute;
    width: functions.var($element + "-popover", width, 100%);
    max-width: functions.var($element + "-popover", max-width, 15rem);
    min-height: functions.var($element + "-popover", min-height, 0);
  }

  &__items {
    display: flex;
    flex: 1;
    flex-direction: column;
  }

  &--compact {
    @include mixins.override-logical(dropdown-item, null, padding, var(--space-4) var(--space-8));
  }
}
</style>

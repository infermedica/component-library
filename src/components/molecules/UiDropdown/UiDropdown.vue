<template>
  <div
    v-click-outside="clickOutsideValue"
    class="ui-dropdown"
    @keydown="handleDropdownKeydown"
  >
    <!-- @slot Use this slot to place toggle template. -->
    <slot
      name="toggle"
      v-bind="{
        text,
        isOpen,
        buttonToggleAttrs,
        handlePopoverToggle,
        handlePopoverOpen,
        handlePopoverClose,
        toggleHandler: handlePopoverToggle,
        openHandler: handlePopoverOpen,
        closeHandler: handlePopoverClose,
      }"
    >
      <UiButton
        ref="toggleButton"
        v-bind="buttonToggleAttrs"
        class="ui-dropdown__toggle"
        :aria-expanded="`${isOpen}`"
        @click="handlePopoverToggle"
      >
        {{ text }}
      </UiButton>
    </slot>
    <!-- @slot Use this slot to replace popover template. -->
    <slot
      name="popover"
      v-bind="{
        isOpen,
        popoverAttrs,
        handlePopoverClose,
        closeHandler: handlePopoverClose,
      }"
    >
      <UiPopover
        v-if="isOpen"
        v-bind="popoverAttrs"
        class="ui-dropdown__popover"
        @close="handlePopoverClose"
      >
        <!-- @slot Use this slot to replace content template. -->
        <slot
          name="content"
          v-bind="{
            isOpen,
            handlePopoverClose,
            closeHandler: handlePopoverClose,
          }"
        >
          <UiMenu
            ref="menu"
            :class="[
              'ui-dropdown__items',
              { 'ui-menu--compact': isCompact },
            ]"
            :enable-keyboard-navigation="enableKeyboardNavigation"
            @items-loaded="handleMenuItemsNotReachable"
          >
            <template
              v-for="(item, key) in itemsToRender"
              :key="key"
            >
              <UiDropdownItem
                v-bind="item"
              >
                <!-- @slot Use this slot to replace dropdown item content. -->
                <slot
                  :name="item.name"
                  v-bind="{ item }"
                >
                  {{ item.label }}
                </slot>
              </UiDropdownItem>
            </template>
          </UiMenu>
        </slot>
      </UiPopover>
    </slot>
  </div>
</template>

<script setup lang="ts">
import {
  ref,
  computed,
  provide,
  useAttrs,
  type ComponentPublicInstance,
  type WritableComputedRef,
} from 'vue';
import { focusElement } from '../../../utilities/helpers';
import {
  clickOutside as vClickOutside,
  type VClickOutsideValue,
} from '../../../utilities/directives';
import UiButton from '../../atoms/UiButton/UiButton.vue';
import type { ButtonAttrsProps } from '../../atoms/UiButton/UiButton.vue';
import UiPopover from '../UiPopover/UiPopover.vue';
import type { PopoverAttrsProps } from '../UiPopover/UiPopover.vue';
import UiMenu from '../../organisms/UiMenu/UiMenu.vue';
import UiDropdownItem from './_internal/UiDropdownItem.vue';
import type { DropdownItemAttrsProps } from './_internal/UiDropdownItem.vue';
import type { DefineAttrsProps } from '../../../types';

export type DropdownModelValue = string | Record<string, unknown>;
export interface DropdownItemComplex extends DropdownItemAttrsProps {
  text?: string;
  name?: string;
}
export type DropdownItem = string | DropdownItemComplex;
export interface DropdownHandlersOptions {
  focusToggle?: boolean;
}
export type ButtonInstance = InstanceType<typeof UiButton>;
export type MenuInstance = InstanceType<typeof UiMenu>;
export interface DropdownProps {
  /**
   * Use this props or v-model to set value.
   */
  modelValue?: DropdownModelValue;
  /**
   * Use this props to set text on toggle button.
   */
  text?: string;
  /**
   * Use this props to set dropdown name.
   * Default value is generated by uid i.e. `dropdown-<uid>`.
   */
  name?: string;
  /**
   * Use this props to pass list of dropdown items.
   */
  items?: DropdownItem[];
  /**
   *  Use this props to pass attrs to toggle UiButton.
   */
  buttonToggleAttrs?: ButtonAttrsProps;
  /**
   *  Use this props to pass attrs to UiPopover.
   */
  popoverAttrs?: PopoverAttrsProps;
  /**
   * Use this props to set toggle DOM element to back to it after close popover.
   */
  toggleElement?: ComponentPublicInstance | HTMLElement | null;
  /**
   * Use this props to allow clicking outside to close dropdown.
   */
  closeOnClickOutside?: boolean;
  /**
   * Use this props to allow using key navigation.
   */
  enableKeyboardNavigation?: boolean;
}
export type DropdownAttrsProps = DefineAttrsProps<DropdownProps>
export interface DropdownEmits {
  (e: 'update:modelValue', value: DropdownModelValue): void;
  (e: 'open'): void;
  (e: 'close'): void;
}

const props = withDefaults(defineProps<DropdownProps>(), {
  modelValue: '',
  text: '',
  name: '',
  items: () => ([]),
  buttonToggleAttrs: () => ({}),
  popoverAttrs: () => ({}),
  toggleElement: null,
  closeOnClickOutside: true,
  enableKeyboardNavigation: true,
});
const emit = defineEmits<DropdownEmits>();
const isOpen = ref(false);
const preventScrollingByArrows = (event: KeyboardEvent) => {
  if ([
    'ArrowUp',
    'ArrowDown',
  ].indexOf(event.code) > -1) {
    event.preventDefault();
  }
};
const menu = ref<MenuInstance | null>(null);
const handleMenuItemsNotReachable = () => {
  if (!menu.value) return;
  if (menu.value.selectedMenuItem) {
    focusElement(menu.value.selectedMenuItem.$el.querySelector('button'));
    return;
  }
  if (menu.value.firstMenuItem) {
    focusElement(menu.value.firstMenuItem.$el.querySelector('button'));
  }
};
const handlePopoverOpen = async () => {
  window.addEventListener('keydown', preventScrollingByArrows, false);
  emit('open');
  isOpen.value = true;
};
const toggleButton = ref<ButtonInstance | null>(null);
const dropdownToggleButton = computed<HTMLElement>(() => {
  if (props.toggleElement) {
    return '$el' in props.toggleElement
      ? props.toggleElement.$el
      : props.toggleElement;
  }
  return toggleButton.value?.$el;
});
const handlePopoverClose = ({ focusToggle }: DropdownHandlersOptions = { focusToggle: true }) => {
  window.removeEventListener('keydown', preventScrollingByArrows, false);
  emit('close');
  isOpen.value = false;
  if (!focusToggle) return;
  focusElement(dropdownToggleButton.value);
};
const modelValue = computed({
  get() {
    return props.modelValue;
  },
  set(value) {
    emit('update:modelValue', value);
    handlePopoverClose();
  },
});
provide<WritableComputedRef<DropdownProps['modelValue']>>('modelValue', modelValue);
const handlePopoverToggle = async () => {
  if (isOpen.value) {
    handlePopoverClose();
    return;
  }
  await handlePopoverOpen();
};
const clickOutsideValue = computed<VClickOutsideValue>(() => ({
  isActive: props.closeOnClickOutside && isOpen.value,
  handler: () => handlePopoverClose(),
}));
const itemsToRender = computed(() => (props.items.map((item, index) => {
  const template = {
    'aria-setsize': props.items.length,
    'aria-posinset': index + 1,
  };
  if (typeof item === 'string') {
    return {
      ...template,
      name: `dropdown-item-${index}`,
      label: item,
      value: item,
    };
  }
  const {
    text,
    value,
    name,
    ...rest
  } = item;
  return {
    ...template,
    name: name || `dropdown-item-${index}`,
    label: text,
    value: value || JSON.parse(JSON.stringify(item)),
    ...rest,
  };
})));
const handleDropdownKeydown = ({ key }: KeyboardEvent) => {
  if (!props.enableKeyboardNavigation) return;
  switch (key) {
    case 'Tab':
    case 'Escape':
      handlePopoverClose();
      break;
    case 'ArrowDown':
      if (!isOpen.value) {
        handlePopoverOpen();
      }
      break;
    default: break;
  }
};
const attrs: DropdownItemAttrsProps = useAttrs();
const isCompact = computed(() => attrs.class && attrs.class.includes('ui-dropdown--compact'));
// TODO: try to remove this exposing
defineExpose({
  isOpen,
  handlePopoverClose,
  closeHandler: handlePopoverClose,
});
</script>

<style lang="scss">
@use "../../../styles/functions";
@use "../../../styles/mixins";

.ui-dropdown {
  $element: dropdown;

  position: relative;
  display: inline-flex;

  &__popover {
    @include mixins.override-logical(popover-content, $element + "-popover", padding, var(--space-4) 0);
    @include mixins.use-logical($element + "-popover", margin, var(--space-8) 0 0);
    @include mixins.use-logical($element + "-popover", inset, 100% auto auto 0);

    position: absolute;
    width: functions.var($element + "-popover", width, 15rem);
    min-height: functions.var($element + "-popover", min-height, 0);
  }
}
</style>

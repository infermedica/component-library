import { Meta } from '@storybook/blocks';
import { PageOutline } from '../components/PageOutline';

<Meta title="Contributing Guide/Testing Guidelines"/>

# Testing Guidelines
Infermedica Component Library use unit tests and [Storybook interactins tests](https://storybook.js.org/docs/vue/writing-tests/interaction-testing) as tools to ensure the
quality of code and user interface. They allow for quick testing of individual code fragments and early detection of potential errors. We can simulate user behavior, such
as clicks, value changes, etc. This allows us to see how components behave in different situations and what their state looks like at different times.

<PageOutline/>

## Test coverage
Test coverage is the practice of measuring whether existing tests fully cover your code. That means surfacing areas which aren't currently being tested, such as:
conditions, logic branches, functions and variables. We use Storybook official test coverage addon. If you want to see the current code coverage, please use this command:
```
pnpm test:coverage-open
```
It will run unit tests and the Storybook test runner, and then present the percentage of code coverage by tests, as well as identify which parts of the code have not been
tested yet.

## Unit Tests
### How to use stories in unit tests
The `mountStories` helper function is used to mount component in the context of Storybook and run tests on them using `@vue/test-utils`.

The function takes three arguments:
- component: Vue component that will be mounted for each story.
- imports: object containing the Storybook metadata and stories from eg. `component.stories.ts`.
- setWrapper: callback function that will be called with the mounted story wrapper for each story.

The function returns a `StoryMap` object that maps the names of the individual stories to a `StoryToMount` function. The StoryToMount function takes an optional
`additionalArgs` parameter which can pass new attributes or overwrite existing props used in the story. This function returns an object with the following properties:
- wrapper: mounted story wrapper.
- component: root component of the mounted story.
- args: object containing the combined set of arguments passed to the story.

#### Example usage
Here's an example usage of the `mountStories` function:
```ts
import { mount } from '@vue/test-utils';
import { mountStories } from '@tests/unit/helpers';
import Component from './MyComponent.vue';
import * as componentStories from './MyComponent.stories';

describe('Component', () => {
  let wrapper: VueWrapper;
  const setWrapper = (storyWrapper: VueWrapper) => {
    wrapper = storyWrapper;
  };
  const { Basic } = mountStories(Component, componentStories, setWrapper);
  afterEach(() => {
    wrapper.unmount();
  });
  test('renders the basic story', () => {
    const { component } = Basic();
    expect(component.exists()).toBe(true);
  });
  test('renders the basic story with additional props', () => {
    const { component, args } = Basic({ foo: 'bar' });
    expect(component.props()).toMatchObject(args);
  });
});
```

### How to test component emits
The `getEmitTests` function is an async helper function that generates a test suite for the emit event and can be used in testing Vue components that emit events.
This function takes two parameters:
- emit: a string that represents the name of the event being emitted.
- testCases: An array of `EmitTestCase` objects that describe the test cases for the event emission.

The `EmitTestCase` type is a generic type that takes an object of type `TArgs` as its parameter. It represents a single test case that describes an emit event.
The EmitTestCase type has the following properties:
- name: string that describes the test case.
- story: function that returns mounted story. This function is generated using the StoryToMount helper function.
- action: function that takes wrapper as parameter and performs some action on the component, such as clicking a button or typing into an input field.
- expected: expected value of the emitted event. If expected is a function, it is called with the args object generated by the story function. If expected is a
required property of `TArgs`, its value is used as the expected value of the emitted event.

This function performs the following steps:
- Calls the story function to mount the story.
- Calls the action function to perform an action on the component.
- Gets the value emitted by the component for the specified emit event.
- Asserts that the emitted value matches the expected value.
- Unmounts the component to clean up after the test.

#### Example usage
Here's an example usage of the `getEmitTests` function:
```ts
import { getEmitTests } from '@tests/unit/helpers';

const getCheckbox = (wrapper: VueWrapper) => wrapper.find('[data-testid="checkbox"]');
const setChecked = (wrapper: VueWrapper) => getCheckbox(wrapper).setValue(true);
const setUnchecked = (wrapper: VueWrapper) => getCheckbox(wrapper).setValue(false);
describe('emits', () => {
getEmitTests(
  'update:modelValue',
  [
    {
      name: 'emit correct value',
      story: Basic(),
      action: setChecked,
      expected: ({ modelValue }) => !modelValue,
    },
    {
      name: 'emit correct value when unchecked',
      story: Basic({ modelValue: true }),
      action: setUnchecked,
      expected: ({ modelValue }) => !modelValue,
    },
  ])
})
```

### How to test component slots
The `getSlotTests` function is used to create tests for components that use named slots. It takes an array of `SlotTestCase` type objects as its argument, which define
the test cases and creates two tests for each slot:
- test checks that the content is rendered via the named slot.
- test checks that the expected binding is passed to the slot element.

The `SlotTestCase` type is used to define a test case for a named slot. It has the following properties:
- story: function that returns mounted story. This function is generated using the StoryToMount helper function.
- slot: name of the slot to test.
- content: function that returns content of the slot.
- expectedBinding: function that returns an object that represents the expected binding for the content slot.

#### Example usage
Here's an example usage of the `getSlotTests` function:
```ts
import { getSlotTests } from '@tests/unit/helpers';

const getLabel = (wrapper: VueWrapper) => wrapper.findComponent(UiText);
const getIcon = (wrapper: VueWrapper) => wrapper.findComponent(UiIcon);
describe('slots', () => {
  getSlotTests([
    {
      slot: 'label',
      story: WithLabelSlot({
        labelAttrs: {
          id: 'test-id',
          'data-testid': 'label',
          class: 'ui-element__label',
          tag: 'p',
        },
      }),
      content: getLabel,
      expectedBinding: ({ labelAttrs }) => labelAttrs,
    },
    {
      slot: 'icon',
      story: WithIconSlot({
        iconAttrs: {
          id: 'test-id',
          'data-testid': 'icon',
          class: 'test-class',
          icon: 'no',
        },
      }),
      content: getIcon,
      expectedBinding: ({ iconAttrs }) => iconAttrs,
    },
  ])
})
```
## Storybook interactions
### How to test styles component in different states
You can use the `withVariant` decorator to render the component in different states and check its correct styles using the `getCSSValue` and `getStyleTests`
helper functions.

The `withVariant` decorator is likely a custom implementation that allows the component to be rendered with different variants or states, such as "active", "disabled",
or "hovered". The `getCSSValue` function is likely used to retrieve the computed style value for a given CSS property on a particular element, and the `getStyleTests`
function is likely used to test whether the computed style values match the expected values for a given set of test cases. By using these functions in conjunction
with the `withVariant` decorator, the correctness of the component's styles can be verified across different states or variants.

The `getStyleTests` function is used to check the correct styles of components in different states. This function takes four parameters:
- elements: an array of DOM elements objects.
- property: a string representing the CSS property to retrieve the computed style for.
- results: expected computed styles for the corresponding elements in the elements array.
- pseudo: an optional string representing a CSS pseudo-selector. If this parameter is not specified, the default computed style for the element will be returned.

#### Example usage
Here's an example usage of the `getStyleTests` function:
```ts
const getBorderTests = async ({
  canvasElement, step,
}: PlayContext, results: Partial<CSSStyleDeclaration>[]) => {
  const elements = [ ...canvasElement.querySelectorAll('.ui-element') ];
  await step('Correct border colors', () => {
    getStyleTests(elements, 'borderColor', results, ':after');
  });
  await step('Correct background colors', () => {
    getStyleTests(elements, 'backgroundColor', results);
  });
};

BasicVariants.decorators = [ withVariants ];
BasicVariants.parameters = {
  variants: [
    {
      label: 'default',
    },
    {
      label: 'hover',
      class: 'pseudo-hover',
    },
    {
      label: 'active',
      class: 'pseudo-active',
    },
  ]
}
BasicVariants.play = async (context) => getStatesTests(context, [
  ...[
    '',
    '-hover',
    '-active',
  ].map((state) => ({
    borderColor: getCSSValue(`--color-border-strong${state}`),
    backgroundColor: getCSSValue(`--color-selectioncontrols-selection${state}`),
  }))
])
```